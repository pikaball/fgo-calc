# FGO 最优羁绊组队求解器

本项目用于在给定限制条件下计算FGO羁绊收益最高的组队。

## 项目结构

- 数据预处理器：从chaldea拉取从者信息，解析生成`data/*.json`
- 前端：裸html/js
- 后端：go/gin

## 问题描述

FGO的队伍有六个槽位，去除助战位之后自出至多五个从者和至多五张礼装。

在没有羁绊加成时，五个从者获得相同的基础羁绊值。

每个从者有一些特性。

一些礼装拥有羁绊加成效果，一般形式为：满足【x特性∧y特性】的从者羁绊值提升【x比例】，一张礼装效果对全体从者都生效。

从者和礼装均有cost值，一个组队的总cost是有上限的。

问题：如何在给定限制条件下获知总羁绊值最大的从者礼装组合？

### 限制条件

所谓限制条件，考虑以下几种：
- COST上限
- 从者数量上限
- 礼装数量上限
- 必须包含的从者
- 排除的从者
- 必须包含的礼装 
- 排除的礼装

为了便于操作，还会提供一个“排除的从者”的补集，“允许的从者”，针对冠位战这种情形。

### 羁绊加成来源

- 大部分羁绊加成礼装都是对羁绊获取量进行百分比加成，但考虑到“英灵肖像”（羁绊+50点）这个特殊礼装的存在，基础羁绊值也必须给定（给出大概值或保持默认即可，经验上来看影响较小）。

- 活动从者羁绊加成在未来会加入计算。

- 前排三个从者有额外独立加成，但算这个加成和不算这个加成的情况的最优解显然是等价的：只需要在得出最优组合后把加成高的从者尽可能置于前排即可，因此求解组合时不必考虑。

- 关于助战，可控性太低，因为fgo构史一样的助战系统不让你逮着一个薅，有时候刷半天刷不到想要的，所以计算时干脆不考虑。但会给出队伍中每张礼装带来的总收益，选助战时可以根据这个选收益最好的礼装。

## 算法实现

### 最优组合计算方法

因为礼装组合数量是数量级足够小的（在有N张羁绊加成礼装的情况下，组合数 $\le \Sigma_{i = 0}^{i \le 5}(C_N^i)$ ，我们确信N是足够小的），所以计算方法其实就是枚举所有礼装组合，然后对礼装和从者解01背包问题。

另外需要注意的一件事是从者的再临和灵衣会导致特性发生改变（例：爱尔奎特的灵基二，班扬的兔子灵衣），甚至cost改变（虽然目前只有玛修一例），而显然不能让不同形态的同一个从者多次出现在一个队伍里。解决办法是固定礼装组合后，先计算一次从者不同形态下的收益，只取最高者。

### 数据建模

从者：
```
id: int
name: str
diff: list[info]
    | info: {
        name: str
        traits: list[trait]
        img: str url
        cost: int
    }
```

礼装：
```
id: int
name: str
img: str url
cost: int
filters: list[filter]
    | filter: list[traits], effect:int
```

### 优化 - 优先级链

预计算和并发之类细枝末节的常规优化不再赘述，这里只介绍优先级链。

上述算法的朴素实现受制于礼装组合数的爆炸，但事实上存在一些绝对上位替代的关系，比如说当你还剩12 cost和一个礼装槽位可以用，并且午茶礼装（无条件+10%）和芙尔摩斯（无条件+5%）都还没选，那么选芙尔摩斯的组合一定不会出现在最优解里，因为至少选午茶的这个组合收益比它高。游戏中的羁绊加成礼装有很多这种无filter条件的，这是整个算法最大的优化点。

形式化地定义关系“绝对优于”：

> 礼装A和B cost相同，且其filter是空（即匹配any），此时如果A的effect大于B，则称A绝对优于B.

由此定义立刻可知： 如果候选礼装中存在A和B，且A绝对优于B。那么如果产生的一个组合包含B而不包含A，那么这个组合可以完全被B->A的组合替换，从而达到减小组合总数规模的目的。

基于此，我们构建一条严格的**优先级链**：

对于所有 cost 相同、无条件 filter 的礼装，按照 effect 从大到小排序，令每个礼装依赖于其直接的下位替代者（例如 A→B→C）：

+ 若组合出现了 B 却不出现 A，则该组合必然可被替换而不会成为最优，故直接剪枝；

+ 若组合出现了 A，则 B 及以下不再需要出现在搜索分支中；

相同effect也应建立依赖，这是因为如果A和B完全等价，那么我们可以无视出现B而不出现A的组合，因为它一定可以被另一个将B的位置替换为A的组合替代，没有必要出现在最终结果里。

注意该依赖必须保持链式传递而不能进行路径压缩：如果 A 绝对优于 B，B 绝对优于 C，那么只选 AC 而不选 B 不可能最优。因此 C 的依赖必须指向 B，而不是直接指向 A。

在实际搜索过程中，候选礼装集合可能因 include/exclude 而缩减，此时需要对优先级链进行动态patch：对每个礼装，沿原链向上回溯，寻找最靠近的、仍处于候选集合的上位礼装，若不存在，则移除其依赖关系。

具体实现请查看函数`BuildDominateMap`, `FixDominateMap`, `GetCombination`

## Deployment

```shell
python3 data.py
python3 ce.py
cd backend
go build .
./fgo-calc-backend
```

## todo

- 分组背包处理cost变化（唉，玛修）
- 增加助战礼装计算
- 增加活动羁绊加成计算
- 交互逻辑优化：职阶图标，星级筛选，多选框